/* tslint:disable */
/* eslint-disable */
/**
 * salmon-donate-backend API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0-SNAPSHOT
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiV1DonationNotificationGet200Response
 */
export interface ApiV1DonationNotificationGet200Response {
    /**
     * Unique event identifier
     * @type {string}
     * @memberof ApiV1DonationNotificationGet200Response
     */
    'id'?: string;
    /**
     * Name of the event (e.g., \'keepalive\', \'new-donation\')
     * @type {string}
     * @memberof ApiV1DonationNotificationGet200Response
     */
    'name'?: ApiV1DonationNotificationGet200ResponseNameEnum;
    /**
     * Optional comment for the event
     * @type {string}
     * @memberof ApiV1DonationNotificationGet200Response
     */
    'comment'?: string;
    /**
     * 
     * @type {ApiV1DonationNotificationGet200ResponseData}
     * @memberof ApiV1DonationNotificationGet200Response
     */
    'data'?: ApiV1DonationNotificationGet200ResponseData;
}

export const ApiV1DonationNotificationGet200ResponseNameEnum = {
    Keepalive: 'keepalive',
    NewDonation: 'new-donation'
} as const;

export type ApiV1DonationNotificationGet200ResponseNameEnum = typeof ApiV1DonationNotificationGet200ResponseNameEnum[keyof typeof ApiV1DonationNotificationGet200ResponseNameEnum];

/**
 * @type ApiV1DonationNotificationGet200ResponseData
 * Actual data of the event
 * @export
 */
export type ApiV1DonationNotificationGet200ResponseData = DonationDTO | object;

/**
 * 
 * @export
 * @interface ApiV1PaymentPaymentIdStatusGet200Response
 */
export interface ApiV1PaymentPaymentIdStatusGet200Response {
    /**
     * Unique event identifier
     * @type {string}
     * @memberof ApiV1PaymentPaymentIdStatusGet200Response
     */
    'id'?: string;
    /**
     * Type of sse event
     * @type {string}
     * @memberof ApiV1PaymentPaymentIdStatusGet200Response
     */
    'name'?: ApiV1PaymentPaymentIdStatusGet200ResponseNameEnum;
    /**
     * 
     * @type {ApiV1PaymentPaymentIdStatusGet200ResponseData}
     * @memberof ApiV1PaymentPaymentIdStatusGet200Response
     */
    'data'?: ApiV1PaymentPaymentIdStatusGet200ResponseData;
}

export const ApiV1PaymentPaymentIdStatusGet200ResponseNameEnum = {
    PaymentChangedStatus: 'payment-changed-status',
    Keepalive: 'keepalive'
} as const;

export type ApiV1PaymentPaymentIdStatusGet200ResponseNameEnum = typeof ApiV1PaymentPaymentIdStatusGet200ResponseNameEnum[keyof typeof ApiV1PaymentPaymentIdStatusGet200ResponseNameEnum];

/**
 * @type ApiV1PaymentPaymentIdStatusGet200ResponseData
 * Details of the payment status update
 * @export
 */
export type ApiV1PaymentPaymentIdStatusGet200ResponseData = InvoiceDTO | object;

/**
 * 
 * @export
 * @enum {string}
 */

export const CoinType = {
    Xmr: 'XMR',
    Btc: 'BTC',
    Ltc: 'LTC',
    Eth: 'ETH',
    Ton: 'TON'
} as const;

export type CoinType = typeof CoinType[keyof typeof CoinType];


/**
 * 
 * @export
 * @enum {string}
 */

export const ConfirmationType = {
    Unconfirmed: 'UNCONFIRMED',
    PartiallyConfirmed: 'PARTIALLY_CONFIRMED',
    Confirmed: 'CONFIRMED'
} as const;

export type ConfirmationType = typeof ConfirmationType[keyof typeof ConfirmationType];


/**
 * 
 * @export
 * @interface CryptoKeysData
 */
export interface CryptoKeysData {
    /**
     * 
     * @type {XmrKeysData}
     * @memberof CryptoKeysData
     */
    'xmr': XmrKeysData;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CryptoType = {
    Xmr: 'XMR'
} as const;

export type CryptoType = typeof CryptoType[keyof typeof CryptoType];


/**
 * 
 * @export
 * @enum {string}
 */

export const CurrencyType = {
    Usd: 'USD'
} as const;

export type CurrencyType = typeof CurrencyType[keyof typeof CurrencyType];


/**
 * 
 * @export
 * @interface DonationDTO
 */
export interface DonationDTO {
    /**
     * 
     * @type {string}
     * @memberof DonationDTO
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof DonationDTO
     */
    'message'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DonationDTO
     */
    'amount'?: number;
    /**
     * 
     * @type {CoinType}
     * @memberof DonationDTO
     */
    'coin': CoinType;
}


/**
 * 
 * @export
 * @interface DonationDTOForReceiver
 */
export interface DonationDTOForReceiver {
    /**
     * 
     * @type {string}
     * @memberof DonationDTOForReceiver
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof DonationDTOForReceiver
     */
    'message'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof DonationDTOForReceiver
     */
    'amount'?: number;
    /**
     * 
     * @type {CoinType}
     * @memberof DonationDTOForReceiver
     */
    'coin'?: CoinType | null;
    /**
     * 
     * @type {string}
     * @memberof DonationDTOForReceiver
     */
    'createdAt': string;
}


/**
 * 
 * @export
 * @interface DonationDTOForReceiverResponse
 */
export interface DonationDTOForReceiverResponse {
    /**
     * 
     * @type {number}
     * @memberof DonationDTOForReceiverResponse
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof DonationDTOForReceiverResponse
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof DonationDTOForReceiverResponse
     */
    'totalCount'?: number;
    /**
     * 
     * @type {Array<DonationDTOForReceiver>}
     * @memberof DonationDTOForReceiverResponse
     */
    'data': Array<DonationDTOForReceiver>;
}
/**
 * 
 * @export
 * @interface DonationData
 */
export interface DonationData {
    /**
     * 
     * @type {string}
     * @memberof DonationData
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof DonationData
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof DonationData
     */
    'avatarUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DonationData
     */
    'bio'?: string | null;
    /**
     * 
     * @type {Set<CryptoType>}
     * @memberof DonationData
     */
    'acceptedCrypto': Set<CryptoType>;
}
/**
 * 
 * @export
 * @interface DonationProfileDataResponse
 */
export interface DonationProfileDataResponse {
    /**
     * 
     * @type {number}
     * @memberof DonationProfileDataResponse
     */
    'minAmount'?: number;
    /**
     * 
     * @type {CurrencyType}
     * @memberof DonationProfileDataResponse
     */
    'minAmountCurrency': CurrencyType;
    /**
     * 
     * @type {number}
     * @memberof DonationProfileDataResponse
     */
    'timeout'?: number;
    /**
     * 
     * @type {ConfirmationType}
     * @memberof DonationProfileDataResponse
     */
    'confirmationType': ConfirmationType;
    /**
     * 
     * @type {CryptoKeysData}
     * @memberof DonationProfileDataResponse
     */
    'cryptoKeysData': CryptoKeysData;
}


/**
 * 
 * @export
 * @interface DonationRequest
 */
export interface DonationRequest {
    /**
     * 
     * @type {string}
     * @memberof DonationRequest
     */
    'from': string;
    /**
     * 
     * @type {string}
     * @memberof DonationRequest
     */
    'message'?: string | null;
    /**
     * 
     * @type {CryptoType}
     * @memberof DonationRequest
     */
    'coin': CryptoType;
}


/**
 * 
 * @export
 * @interface DonationStatsPeriodResponse
 */
export interface DonationStatsPeriodResponse {
    /**
     * 
     * @type {number}
     * @memberof DonationStatsPeriodResponse
     */
    'donationCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DonationStatsPeriodResponse
     */
    'amount'?: number;
    /**
     * 
     * @type {number}
     * @memberof DonationStatsPeriodResponse
     */
    'avgAmount'?: number;
    /**
     * 
     * @type {Array<DonationDTOForReceiver>}
     * @memberof DonationStatsPeriodResponse
     */
    'top3DonationsByAmount': Array<DonationDTOForReceiver>;
    /**
     * 
     * @type {StatsPeriod}
     * @memberof DonationStatsPeriodResponse
     */
    'period': StatsPeriod;
    /**
     * 
     * @type {CurrencyType}
     * @memberof DonationStatsPeriodResponse
     */
    'amountCurrency': CurrencyType;
}


/**
 * 
 * @export
 * @interface InvoiceDTO
 */
export interface InvoiceDTO {
    /**
     * 
     * @type {string}
     * @memberof InvoiceDTO
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDTO
     */
    'cryptoAddress': string;
    /**
     * 
     * @type {CoinType}
     * @memberof InvoiceDTO
     */
    'coin': CoinType;
    /**
     * 
     * @type {number}
     * @memberof InvoiceDTO
     */
    'requiredAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceDTO
     */
    'actualAmount'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof InvoiceDTO
     */
    'confirmationsRequired'?: number;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDTO
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDTO
     */
    'confirmedAt'?: string | null;
    /**
     * 
     * @type {InvoiceStatusType}
     * @memberof InvoiceDTO
     */
    'status': InvoiceStatusType;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDTO
     */
    'expiresAt': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDTO
     */
    'txId'?: string | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const InvoiceStatusType = {
    Pending: 'PENDING',
    PendingMempool: 'PENDING_MEMPOOL',
    Expired: 'EXPIRED',
    Confirmed: 'CONFIRMED'
} as const;

export type InvoiceStatusType = typeof InvoiceStatusType[keyof typeof InvoiceStatusType];


/**
 * 
 * @export
 * @interface InvoiceToPayDTO
 */
export interface InvoiceToPayDTO {
    /**
     * 
     * @type {string}
     * @memberof InvoiceToPayDTO
     */
    'paymentId': string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceToPayDTO
     */
    'cryptoAddress': string;
    /**
     * 
     * @type {CoinType}
     * @memberof InvoiceToPayDTO
     */
    'coin': CoinType;
    /**
     * 
     * @type {number}
     * @memberof InvoiceToPayDTO
     */
    'requiredAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceToPayDTO
     */
    'timeout'?: number;
    /**
     * 
     * @type {number}
     * @memberof InvoiceToPayDTO
     */
    'confirmationsRequired'?: number;
}


/**
 * 
 * @export
 * @interface KeycloakEventRequest
 */
export interface KeycloakEventRequest {
    /**
     * 
     * @type {number}
     * @memberof KeycloakEventRequest
     */
    'time'?: number | null;
    /**
     * 
     * @type {KeycloakEventType}
     * @memberof KeycloakEventRequest
     */
    'type'?: KeycloakEventType | null;
    /**
     * 
     * @type {string}
     * @memberof KeycloakEventRequest
     */
    'realmId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KeycloakEventRequest
     */
    'clientId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KeycloakEventRequest
     */
    'userId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KeycloakEventRequest
     */
    'ipAddress'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof KeycloakEventRequest
     */
    'error'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof KeycloakEventRequest
     */
    'details'?: { [key: string]: string; } | null;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const KeycloakEventType = {
    AuthreqidToToken: 'AUTHREQID_TO_TOKEN',
    AuthreqidToTokenError: 'AUTHREQID_TO_TOKEN_ERROR',
    ClientDelete: 'CLIENT_DELETE',
    ClientDeleteError: 'CLIENT_DELETE_ERROR',
    ClientInfo: 'CLIENT_INFO',
    ClientInfoError: 'CLIENT_INFO_ERROR',
    ClientInitiatedAccountLinking: 'CLIENT_INITIATED_ACCOUNT_LINKING',
    ClientInitiatedAccountLinkingError: 'CLIENT_INITIATED_ACCOUNT_LINKING_ERROR',
    ClientLogin: 'CLIENT_LOGIN',
    ClientLoginError: 'CLIENT_LOGIN_ERROR',
    ClientRegister: 'CLIENT_REGISTER',
    ClientRegisterError: 'CLIENT_REGISTER_ERROR',
    ClientUpdate: 'CLIENT_UPDATE',
    ClientUpdateError: 'CLIENT_UPDATE_ERROR',
    CodeToToken: 'CODE_TO_TOKEN',
    CodeToTokenError: 'CODE_TO_TOKEN_ERROR',
    CustomRequiredAction: 'CUSTOM_REQUIRED_ACTION',
    CustomRequiredActionError: 'CUSTOM_REQUIRED_ACTION_ERROR',
    DeleteAccount: 'DELETE_ACCOUNT',
    DeleteAccountError: 'DELETE_ACCOUNT_ERROR',
    ExecuteActionToken: 'EXECUTE_ACTION_TOKEN',
    ExecuteActionTokenError: 'EXECUTE_ACTION_TOKEN_ERROR',
    ExecuteActions: 'EXECUTE_ACTIONS',
    ExecuteActionsError: 'EXECUTE_ACTIONS_ERROR',
    FederatedIdentityLink: 'FEDERATED_IDENTITY_LINK',
    FederatedIdentityLinkError: 'FEDERATED_IDENTITY_LINK_ERROR',
    GrantConsent: 'GRANT_CONSENT',
    GrantConsentError: 'GRANT_CONSENT_ERROR',
    IdentityProviderFirstLogin: 'IDENTITY_PROVIDER_FIRST_LOGIN',
    IdentityProviderFirstLoginError: 'IDENTITY_PROVIDER_FIRST_LOGIN_ERROR',
    IdentityProviderLinkAccount: 'IDENTITY_PROVIDER_LINK_ACCOUNT',
    IdentityProviderLinkAccountError: 'IDENTITY_PROVIDER_LINK_ACCOUNT_ERROR',
    IdentityProviderLogin: 'IDENTITY_PROVIDER_LOGIN',
    IdentityProviderLoginError: 'IDENTITY_PROVIDER_LOGIN_ERROR',
    IdentityProviderPostLogin: 'IDENTITY_PROVIDER_POST_LOGIN',
    IdentityProviderPostLoginError: 'IDENTITY_PROVIDER_POST_LOGIN_ERROR',
    IdentityProviderResponse: 'IDENTITY_PROVIDER_RESPONSE',
    IdentityProviderResponseError: 'IDENTITY_PROVIDER_RESPONSE_ERROR',
    IdentityProviderRetrieveToken: 'IDENTITY_PROVIDER_RETRIEVE_TOKEN',
    IdentityProviderRetrieveTokenError: 'IDENTITY_PROVIDER_RETRIEVE_TOKEN_ERROR',
    Impersonate: 'IMPERSONATE',
    ImpersonateError: 'IMPERSONATE_ERROR',
    IntrospectToken: 'INTROSPECT_TOKEN',
    IntrospectTokenError: 'INTROSPECT_TOKEN_ERROR',
    InvalidSignature: 'INVALID_SIGNATURE',
    InvalidSignatureError: 'INVALID_SIGNATURE_ERROR',
    Login: 'LOGIN',
    LoginError: 'LOGIN_ERROR',
    Logout: 'LOGOUT',
    LogoutError: 'LOGOUT_ERROR',
    Oauth2DeviceAuth: 'OAUTH2_DEVICE_AUTH',
    Oauth2DeviceAuthError: 'OAUTH2_DEVICE_AUTH_ERROR',
    Oauth2DeviceCodeToToken: 'OAUTH2_DEVICE_CODE_TO_TOKEN',
    Oauth2DeviceCodeToTokenError: 'OAUTH2_DEVICE_CODE_TO_TOKEN_ERROR',
    Oauth2DeviceVerifyUserCode: 'OAUTH2_DEVICE_VERIFY_USER_CODE',
    Oauth2DeviceVerifyUserCodeError: 'OAUTH2_DEVICE_VERIFY_USER_CODE_ERROR',
    PermissionToken: 'PERMISSION_TOKEN',
    PermissionTokenError: 'PERMISSION_TOKEN_ERROR',
    PushedAuthorizationRequest: 'PUSHED_AUTHORIZATION_REQUEST',
    PushedAuthorizationRequestError: 'PUSHED_AUTHORIZATION_REQUEST_ERROR',
    RefreshToken: 'REFRESH_TOKEN',
    RefreshTokenError: 'REFRESH_TOKEN_ERROR',
    Register: 'REGISTER',
    RegisterError: 'REGISTER_ERROR',
    RegisterNode: 'REGISTER_NODE',
    RegisterNodeError: 'REGISTER_NODE_ERROR',
    RemoveFederatedIdentity: 'REMOVE_FEDERATED_IDENTITY',
    RemoveFederatedIdentityError: 'REMOVE_FEDERATED_IDENTITY_ERROR',
    RemoveTotp: 'REMOVE_TOTP',
    RemoveTotpError: 'REMOVE_TOTP_ERROR',
    ResetPassword: 'RESET_PASSWORD',
    ResetPasswordError: 'RESET_PASSWORD_ERROR',
    RestartAuthentication: 'RESTART_AUTHENTICATION',
    RestartAuthenticationError: 'RESTART_AUTHENTICATION_ERROR',
    RevokeGrant: 'REVOKE_GRANT',
    RevokeGrantError: 'REVOKE_GRANT_ERROR',
    SendIdentityProviderLink: 'SEND_IDENTITY_PROVIDER_LINK',
    SendIdentityProviderLinkError: 'SEND_IDENTITY_PROVIDER_LINK_ERROR',
    SendResetPassword: 'SEND_RESET_PASSWORD',
    SendResetPasswordError: 'SEND_RESET_PASSWORD_ERROR',
    SendVerifyEmail: 'SEND_VERIFY_EMAIL',
    SendVerifyEmailError: 'SEND_VERIFY_EMAIL_ERROR',
    TokenExchange: 'TOKEN_EXCHANGE',
    TokenExchangeError: 'TOKEN_EXCHANGE_ERROR',
    UnregisterNode: 'UNREGISTER_NODE',
    UnregisterNodeError: 'UNREGISTER_NODE_ERROR',
    UpdateConsent: 'UPDATE_CONSENT',
    UpdateConsentError: 'UPDATE_CONSENT_ERROR',
    UpdateEmail: 'UPDATE_EMAIL',
    UpdateEmailError: 'UPDATE_EMAIL_ERROR',
    UpdatePassword: 'UPDATE_PASSWORD',
    UpdatePasswordError: 'UPDATE_PASSWORD_ERROR',
    UpdateProfile: 'UPDATE_PROFILE',
    UpdateProfileError: 'UPDATE_PROFILE_ERROR',
    UpdateTotp: 'UPDATE_TOTP',
    UpdateTotpError: 'UPDATE_TOTP_ERROR',
    UserInfoRequest: 'USER_INFO_REQUEST',
    UserInfoRequestError: 'USER_INFO_REQUEST_ERROR',
    ValidateAccessToken: 'VALIDATE_ACCESS_TOKEN',
    ValidateAccessTokenError: 'VALIDATE_ACCESS_TOKEN_ERROR',
    VerifyEmail: 'VERIFY_EMAIL',
    VerifyEmailError: 'VERIFY_EMAIL_ERROR',
    VerifyProfile: 'VERIFY_PROFILE',
    VerifyProfileError: 'VERIFY_PROFILE_ERROR'
} as const;

export type KeycloakEventType = typeof KeycloakEventType[keyof typeof KeycloakEventType];


/**
 * 
 * @export
 * @interface ProfileDataResponse
 */
export interface ProfileDataResponse {
    /**
     * 
     * @type {string}
     * @memberof ProfileDataResponse
     */
    'avatarUrl'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileDataResponse
     */
    'bio'?: string | null;
}
/**
 * 
 * @export
 * @interface ProfileDataUpdateRequest
 */
export interface ProfileDataUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfileDataUpdateRequest
     */
    'bio'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileDataUpdateRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileDataUpdateRequest
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface RegionalProfileDataRequest
 */
export interface RegionalProfileDataRequest {
    /**
     * 
     * @type {string}
     * @memberof RegionalProfileDataRequest
     */
    'timeZoneName': string;
    /**
     * 
     * @type {CurrencyType}
     * @memberof RegionalProfileDataRequest
     */
    'currency': CurrencyType;
}


/**
 * 
 * @export
 * @interface RegionalProfileDataResponse
 */
export interface RegionalProfileDataResponse {
    /**
     * 
     * @type {TimeZone}
     * @memberof RegionalProfileDataResponse
     */
    'timeZone': TimeZone;
    /**
     * 
     * @type {Array<TimeZone>}
     * @memberof RegionalProfileDataResponse
     */
    'availableTimeZones': Array<TimeZone>;
    /**
     * 
     * @type {CurrencyType}
     * @memberof RegionalProfileDataResponse
     */
    'currency': CurrencyType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const StatsPeriod = {
    Month: 'MONTH',
    AllTime: 'ALL_TIME'
} as const;

export type StatsPeriod = typeof StatsPeriod[keyof typeof StatsPeriod];


/**
 * 
 * @export
 * @interface TimeZone
 */
export interface TimeZone {
    /**
     * 
     * @type {string}
     * @memberof TimeZone
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof TimeZone
     */
    'offset'?: number;
}
/**
 * 
 * @export
 * @interface UpdateDonationProfileDataRequest
 */
export interface UpdateDonationProfileDataRequest {
    /**
     * 
     * @type {number}
     * @memberof UpdateDonationProfileDataRequest
     */
    'minAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateDonationProfileDataRequest
     */
    'timeout'?: number;
    /**
     * 
     * @type {ConfirmationType}
     * @memberof UpdateDonationProfileDataRequest
     */
    'confirmationType': ConfirmationType;
}


/**
 * 
 * @export
 * @interface UpdateXMRDataRequest
 */
export interface UpdateXMRDataRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateXMRDataRequest
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {XmrKeys}
     * @memberof UpdateXMRDataRequest
     */
    'keys': XmrKeys;
}
/**
 * 
 * @export
 * @interface XmrKeys
 */
export interface XmrKeys {
    /**
     * 
     * @type {string}
     * @memberof XmrKeys
     */
    'priv': string;
    /**
     * 
     * @type {string}
     * @memberof XmrKeys
     */
    'pub': string;
}
/**
 * 
 * @export
 * @interface XmrKeysData
 */
export interface XmrKeysData {
    /**
     * 
     * @type {XmrKeys}
     * @memberof XmrKeysData
     */
    'keys': XmrKeys;
    /**
     * 
     * @type {boolean}
     * @memberof XmrKeysData
     */
    'enabled'?: boolean;
}

/**
 * DonationResourceApi - axios parameter creator
 * @export
 */
export const DonationResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches the donation data for a specific user.
         * @summary Get donation data by username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DonationDonateUsernameGet: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('apiV1DonationDonateUsernameGet', 'username', username)
            const localVarPath = `/api/v1/donation/donate/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Processes a donation for the specified user.
         * @summary Make a donation
         * @param {string} username 
         * @param {DonationRequest} [donationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DonationDonateUsernamePost: async (username: string, donationRequest?: DonationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('apiV1DonationDonateUsernamePost', 'username', username)
            const localVarPath = `/api/v1/donation/donate/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(donationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a list of donations with pagination for the authenticated user.
         * @summary Retrieve paginated donations for the authenticated user
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DonationDonationsGet: async (limit?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/donation/donations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint provides real-time donation notifications for the authenticated user via SSE.
         * @summary Subscribe to donation notifications via Server-Sent Events (SSE)
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DonationNotificationGet: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('apiV1DonationNotificationGet', 'token', token)
            const localVarPath = `/api/v1/donation/notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows sending a test donation.
         * @summary Send a test donation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DonationNotificationTestPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/donation/notification/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DonationResourceApi - functional programming interface
 * @export
 */
export const DonationResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DonationResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetches the donation data for a specific user.
         * @summary Get donation data by username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DonationDonateUsernameGet(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DonationData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1DonationDonateUsernameGet(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationResourceApi.apiV1DonationDonateUsernameGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Processes a donation for the specified user.
         * @summary Make a donation
         * @param {string} username 
         * @param {DonationRequest} [donationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DonationDonateUsernamePost(username: string, donationRequest?: DonationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceToPayDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1DonationDonateUsernamePost(username, donationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationResourceApi.apiV1DonationDonateUsernamePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches a list of donations with pagination for the authenticated user.
         * @summary Retrieve paginated donations for the authenticated user
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DonationDonationsGet(limit?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DonationDTOForReceiverResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1DonationDonationsGet(limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationResourceApi.apiV1DonationDonationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint provides real-time donation notifications for the authenticated user via SSE.
         * @summary Subscribe to donation notifications via Server-Sent Events (SSE)
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DonationNotificationGet(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1DonationNotificationGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1DonationNotificationGet(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationResourceApi.apiV1DonationNotificationGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows sending a test donation.
         * @summary Send a test donation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1DonationNotificationTestPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1DonationNotificationTestPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DonationResourceApi.apiV1DonationNotificationTestPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DonationResourceApi - factory interface
 * @export
 */
export const DonationResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DonationResourceApiFp(configuration)
    return {
        /**
         * Fetches the donation data for a specific user.
         * @summary Get donation data by username
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DonationDonateUsernameGet(username: string, options?: RawAxiosRequestConfig): AxiosPromise<DonationData> {
            return localVarFp.apiV1DonationDonateUsernameGet(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Processes a donation for the specified user.
         * @summary Make a donation
         * @param {string} username 
         * @param {DonationRequest} [donationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DonationDonateUsernamePost(username: string, donationRequest?: DonationRequest, options?: RawAxiosRequestConfig): AxiosPromise<InvoiceToPayDTO> {
            return localVarFp.apiV1DonationDonateUsernamePost(username, donationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a list of donations with pagination for the authenticated user.
         * @summary Retrieve paginated donations for the authenticated user
         * @param {number} [limit] 
         * @param {number} [page] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DonationDonationsGet(limit?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<DonationDTOForReceiverResponse> {
            return localVarFp.apiV1DonationDonationsGet(limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint provides real-time donation notifications for the authenticated user via SSE.
         * @summary Subscribe to donation notifications via Server-Sent Events (SSE)
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DonationNotificationGet(token: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1DonationNotificationGet200Response> {
            return localVarFp.apiV1DonationNotificationGet(token, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows sending a test donation.
         * @summary Send a test donation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1DonationNotificationTestPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1DonationNotificationTestPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DonationResourceApi - object-oriented interface
 * @export
 * @class DonationResourceApi
 * @extends {BaseAPI}
 */
export class DonationResourceApi extends BaseAPI {
    /**
     * Fetches the donation data for a specific user.
     * @summary Get donation data by username
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonationResourceApi
     */
    public apiV1DonationDonateUsernameGet(username: string, options?: RawAxiosRequestConfig) {
        return DonationResourceApiFp(this.configuration).apiV1DonationDonateUsernameGet(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Processes a donation for the specified user.
     * @summary Make a donation
     * @param {string} username 
     * @param {DonationRequest} [donationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonationResourceApi
     */
    public apiV1DonationDonateUsernamePost(username: string, donationRequest?: DonationRequest, options?: RawAxiosRequestConfig) {
        return DonationResourceApiFp(this.configuration).apiV1DonationDonateUsernamePost(username, donationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a list of donations with pagination for the authenticated user.
     * @summary Retrieve paginated donations for the authenticated user
     * @param {number} [limit] 
     * @param {number} [page] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonationResourceApi
     */
    public apiV1DonationDonationsGet(limit?: number, page?: number, options?: RawAxiosRequestConfig) {
        return DonationResourceApiFp(this.configuration).apiV1DonationDonationsGet(limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint provides real-time donation notifications for the authenticated user via SSE.
     * @summary Subscribe to donation notifications via Server-Sent Events (SSE)
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonationResourceApi
     */
    public apiV1DonationNotificationGet(token: string, options?: RawAxiosRequestConfig) {
        return DonationResourceApiFp(this.configuration).apiV1DonationNotificationGet(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows sending a test donation.
     * @summary Send a test donation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DonationResourceApi
     */
    public apiV1DonationNotificationTestPost(options?: RawAxiosRequestConfig) {
        return DonationResourceApiFp(this.configuration).apiV1DonationNotificationTestPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PaymentResourceApi - axios parameter creator
 * @export
 */
export const PaymentResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches the details of a donation invoice associated with the given payment ID.
         * @summary Retrieve donation invoice by payment ID
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PaymentPaymentIdDonationGet: async (paymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('apiV1PaymentPaymentIdDonationGet', 'paymentId', paymentId)
            const localVarPath = `/api/v1/payment/{paymentId}/donation`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Subscribe to real-time payment status updates for a specific payment ID using Server-Sent Events (SSE).
         * @summary Get payment status updates via SSE
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PaymentPaymentIdStatusGet: async (paymentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('apiV1PaymentPaymentIdStatusGet', 'paymentId', paymentId)
            const localVarPath = `/api/v1/payment/{paymentId}/status`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentResourceApi - functional programming interface
 * @export
 */
export const PaymentResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PaymentResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetches the details of a donation invoice associated with the given payment ID.
         * @summary Retrieve donation invoice by payment ID
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PaymentPaymentIdDonationGet(paymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InvoiceToPayDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PaymentPaymentIdDonationGet(paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentResourceApi.apiV1PaymentPaymentIdDonationGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Subscribe to real-time payment status updates for a specific payment ID using Server-Sent Events (SSE).
         * @summary Get payment status updates via SSE
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1PaymentPaymentIdStatusGet(paymentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiV1PaymentPaymentIdStatusGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1PaymentPaymentIdStatusGet(paymentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PaymentResourceApi.apiV1PaymentPaymentIdStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PaymentResourceApi - factory interface
 * @export
 */
export const PaymentResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PaymentResourceApiFp(configuration)
    return {
        /**
         * Fetches the details of a donation invoice associated with the given payment ID.
         * @summary Retrieve donation invoice by payment ID
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PaymentPaymentIdDonationGet(paymentId: string, options?: RawAxiosRequestConfig): AxiosPromise<InvoiceToPayDTO> {
            return localVarFp.apiV1PaymentPaymentIdDonationGet(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Subscribe to real-time payment status updates for a specific payment ID using Server-Sent Events (SSE).
         * @summary Get payment status updates via SSE
         * @param {string} paymentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1PaymentPaymentIdStatusGet(paymentId: string, options?: RawAxiosRequestConfig): AxiosPromise<ApiV1PaymentPaymentIdStatusGet200Response> {
            return localVarFp.apiV1PaymentPaymentIdStatusGet(paymentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PaymentResourceApi - object-oriented interface
 * @export
 * @class PaymentResourceApi
 * @extends {BaseAPI}
 */
export class PaymentResourceApi extends BaseAPI {
    /**
     * Fetches the details of a donation invoice associated with the given payment ID.
     * @summary Retrieve donation invoice by payment ID
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentResourceApi
     */
    public apiV1PaymentPaymentIdDonationGet(paymentId: string, options?: RawAxiosRequestConfig) {
        return PaymentResourceApiFp(this.configuration).apiV1PaymentPaymentIdDonationGet(paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Subscribe to real-time payment status updates for a specific payment ID using Server-Sent Events (SSE).
     * @summary Get payment status updates via SSE
     * @param {string} paymentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentResourceApi
     */
    public apiV1PaymentPaymentIdStatusGet(paymentId: string, options?: RawAxiosRequestConfig) {
        return PaymentResourceApiFp(this.configuration).apiV1PaymentPaymentIdStatusGet(paymentId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StatsResourceApi - axios parameter creator
 * @export
 */
export const StatsResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches donation statistics for the authenticated user based on the specified period.
         * @summary Retrieve donation statistics by period
         * @param {StatsPeriod} period 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StatsDonationGet: async (period: StatsPeriod, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'period' is not null or undefined
            assertParamExists('apiV1StatsDonationGet', 'period', period)
            const localVarPath = `/api/v1/stats/donation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatsResourceApi - functional programming interface
 * @export
 */
export const StatsResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatsResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetches donation statistics for the authenticated user based on the specified period.
         * @summary Retrieve donation statistics by period
         * @param {StatsPeriod} period 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1StatsDonationGet(period: StatsPeriod, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DonationStatsPeriodResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1StatsDonationGet(period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatsResourceApi.apiV1StatsDonationGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatsResourceApi - factory interface
 * @export
 */
export const StatsResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatsResourceApiFp(configuration)
    return {
        /**
         * Fetches donation statistics for the authenticated user based on the specified period.
         * @summary Retrieve donation statistics by period
         * @param {StatsPeriod} period 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1StatsDonationGet(period: StatsPeriod, options?: RawAxiosRequestConfig): AxiosPromise<DonationStatsPeriodResponse> {
            return localVarFp.apiV1StatsDonationGet(period, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatsResourceApi - object-oriented interface
 * @export
 * @class StatsResourceApi
 * @extends {BaseAPI}
 */
export class StatsResourceApi extends BaseAPI {
    /**
     * Fetches donation statistics for the authenticated user based on the specified period.
     * @summary Retrieve donation statistics by period
     * @param {StatsPeriod} period 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatsResourceApi
     */
    public apiV1StatsDonationGet(period: StatsPeriod, options?: RawAxiosRequestConfig) {
        return StatsResourceApiFp(this.configuration).apiV1StatsDonationGet(period, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserResourceApi - axios parameter creator
 * @export
 */
export const UserResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint allows an authenticated user to upload a new profile avatar.
         * @summary Update the profile avatar for the authenticated user
         * @param {File} [avatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileAvatarPut: async (avatar?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/profile/avatar`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication SecurityScheme required


            if (avatar !== undefined) { 
                localVarFormParams.append('avatar', avatar as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the donation-related data for the user identified by the JWT token.
         * @summary Get the donation data for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileDonationDataGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/profile/donation_data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the donation-related data for the user identified by the JWT token.
         * @summary Update the donation data for the authenticated user
         * @param {UpdateDonationProfileDataRequest} [updateDonationProfileDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileDonationDataPut: async (updateDonationProfileDataRequest?: UpdateDonationProfileDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/profile/donation_data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDonationProfileDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the XMR donation-related data for the user identified by the JWT token.
         * @summary Update the XMR donation data for the authenticated user
         * @param {UpdateXMRDataRequest} [updateXMRDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileDonationDataXmrPut: async (updateXMRDataRequest?: UpdateXMRDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/profile/donation_data/xmr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateXMRDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the profile data for the user identified by the JWT token.
         * @summary Get the profile data for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the notification token associated with the current user.
         * @summary Get the user\'s notification token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileNotificationGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/profile/notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Regenerate a new notification token for the current user.
         * @summary Regenerate the user\'s notification token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileNotificationPut: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/profile/notification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows an authenticated user to update their profile information.
         * @summary Update the profile data for the authenticated user
         * @param {ProfileDataUpdateRequest} [profileDataUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfilePut: async (profileDataUpdateRequest?: ProfileDataUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/profile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileDataUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches the regional settings data for the authenticated user.
         * @summary Retrieve regional settings for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileRegionalGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/profile/regional`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the regional settings data for the authenticated user.
         * @summary Update regional settings for the user
         * @param {RegionalProfileDataRequest} [regionalProfileDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileRegionalPut: async (regionalProfileDataRequest?: RegionalProfileDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/user/profile/regional`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication SecurityScheme required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(regionalProfileDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserResourceApi - functional programming interface
 * @export
 */
export const UserResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint allows an authenticated user to upload a new profile avatar.
         * @summary Update the profile avatar for the authenticated user
         * @param {File} [avatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProfileAvatarPut(avatar?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserProfileAvatarPut(avatar, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceApi.apiV1UserProfileAvatarPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches the donation-related data for the user identified by the JWT token.
         * @summary Get the donation data for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProfileDonationDataGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DonationProfileDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserProfileDonationDataGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceApi.apiV1UserProfileDonationDataGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the donation-related data for the user identified by the JWT token.
         * @summary Update the donation data for the authenticated user
         * @param {UpdateDonationProfileDataRequest} [updateDonationProfileDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProfileDonationDataPut(updateDonationProfileDataRequest?: UpdateDonationProfileDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserProfileDonationDataPut(updateDonationProfileDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceApi.apiV1UserProfileDonationDataPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the XMR donation-related data for the user identified by the JWT token.
         * @summary Update the XMR donation data for the authenticated user
         * @param {UpdateXMRDataRequest} [updateXMRDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProfileDonationDataXmrPut(updateXMRDataRequest?: UpdateXMRDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserProfileDonationDataXmrPut(updateXMRDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceApi.apiV1UserProfileDonationDataXmrPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches the profile data for the user identified by the JWT token.
         * @summary Get the profile data for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProfileGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserProfileGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceApi.apiV1UserProfileGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the notification token associated with the current user.
         * @summary Get the user\'s notification token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProfileNotificationGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserProfileNotificationGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceApi.apiV1UserProfileNotificationGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Regenerate a new notification token for the current user.
         * @summary Regenerate the user\'s notification token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProfileNotificationPut(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserProfileNotificationPut(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceApi.apiV1UserProfileNotificationPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint allows an authenticated user to update their profile information.
         * @summary Update the profile data for the authenticated user
         * @param {ProfileDataUpdateRequest} [profileDataUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProfilePut(profileDataUpdateRequest?: ProfileDataUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserProfilePut(profileDataUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceApi.apiV1UserProfilePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches the regional settings data for the authenticated user.
         * @summary Retrieve regional settings for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProfileRegionalGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionalProfileDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserProfileRegionalGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceApi.apiV1UserProfileRegionalGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the regional settings data for the authenticated user.
         * @summary Update regional settings for the user
         * @param {RegionalProfileDataRequest} [regionalProfileDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1UserProfileRegionalPut(regionalProfileDataRequest?: RegionalProfileDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1UserProfileRegionalPut(regionalProfileDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserResourceApi.apiV1UserProfileRegionalPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserResourceApi - factory interface
 * @export
 */
export const UserResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserResourceApiFp(configuration)
    return {
        /**
         * This endpoint allows an authenticated user to upload a new profile avatar.
         * @summary Update the profile avatar for the authenticated user
         * @param {File} [avatar] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileAvatarPut(avatar?: File, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1UserProfileAvatarPut(avatar, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the donation-related data for the user identified by the JWT token.
         * @summary Get the donation data for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileDonationDataGet(options?: RawAxiosRequestConfig): AxiosPromise<DonationProfileDataResponse> {
            return localVarFp.apiV1UserProfileDonationDataGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the donation-related data for the user identified by the JWT token.
         * @summary Update the donation data for the authenticated user
         * @param {UpdateDonationProfileDataRequest} [updateDonationProfileDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileDonationDataPut(updateDonationProfileDataRequest?: UpdateDonationProfileDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1UserProfileDonationDataPut(updateDonationProfileDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the XMR donation-related data for the user identified by the JWT token.
         * @summary Update the XMR donation data for the authenticated user
         * @param {UpdateXMRDataRequest} [updateXMRDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileDonationDataXmrPut(updateXMRDataRequest?: UpdateXMRDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1UserProfileDonationDataXmrPut(updateXMRDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the profile data for the user identified by the JWT token.
         * @summary Get the profile data for the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileGet(options?: RawAxiosRequestConfig): AxiosPromise<ProfileDataResponse> {
            return localVarFp.apiV1UserProfileGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the notification token associated with the current user.
         * @summary Get the user\'s notification token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileNotificationGet(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.apiV1UserProfileNotificationGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Regenerate a new notification token for the current user.
         * @summary Regenerate the user\'s notification token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileNotificationPut(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.apiV1UserProfileNotificationPut(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows an authenticated user to update their profile information.
         * @summary Update the profile data for the authenticated user
         * @param {ProfileDataUpdateRequest} [profileDataUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfilePut(profileDataUpdateRequest?: ProfileDataUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1UserProfilePut(profileDataUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches the regional settings data for the authenticated user.
         * @summary Retrieve regional settings for the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileRegionalGet(options?: RawAxiosRequestConfig): AxiosPromise<RegionalProfileDataResponse> {
            return localVarFp.apiV1UserProfileRegionalGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the regional settings data for the authenticated user.
         * @summary Update regional settings for the user
         * @param {RegionalProfileDataRequest} [regionalProfileDataRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1UserProfileRegionalPut(regionalProfileDataRequest?: RegionalProfileDataRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1UserProfileRegionalPut(regionalProfileDataRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserResourceApi - object-oriented interface
 * @export
 * @class UserResourceApi
 * @extends {BaseAPI}
 */
export class UserResourceApi extends BaseAPI {
    /**
     * This endpoint allows an authenticated user to upload a new profile avatar.
     * @summary Update the profile avatar for the authenticated user
     * @param {File} [avatar] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceApi
     */
    public apiV1UserProfileAvatarPut(avatar?: File, options?: RawAxiosRequestConfig) {
        return UserResourceApiFp(this.configuration).apiV1UserProfileAvatarPut(avatar, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches the donation-related data for the user identified by the JWT token.
     * @summary Get the donation data for the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceApi
     */
    public apiV1UserProfileDonationDataGet(options?: RawAxiosRequestConfig) {
        return UserResourceApiFp(this.configuration).apiV1UserProfileDonationDataGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the donation-related data for the user identified by the JWT token.
     * @summary Update the donation data for the authenticated user
     * @param {UpdateDonationProfileDataRequest} [updateDonationProfileDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceApi
     */
    public apiV1UserProfileDonationDataPut(updateDonationProfileDataRequest?: UpdateDonationProfileDataRequest, options?: RawAxiosRequestConfig) {
        return UserResourceApiFp(this.configuration).apiV1UserProfileDonationDataPut(updateDonationProfileDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the XMR donation-related data for the user identified by the JWT token.
     * @summary Update the XMR donation data for the authenticated user
     * @param {UpdateXMRDataRequest} [updateXMRDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceApi
     */
    public apiV1UserProfileDonationDataXmrPut(updateXMRDataRequest?: UpdateXMRDataRequest, options?: RawAxiosRequestConfig) {
        return UserResourceApiFp(this.configuration).apiV1UserProfileDonationDataXmrPut(updateXMRDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches the profile data for the user identified by the JWT token.
     * @summary Get the profile data for the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceApi
     */
    public apiV1UserProfileGet(options?: RawAxiosRequestConfig) {
        return UserResourceApiFp(this.configuration).apiV1UserProfileGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the notification token associated with the current user.
     * @summary Get the user\'s notification token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceApi
     */
    public apiV1UserProfileNotificationGet(options?: RawAxiosRequestConfig) {
        return UserResourceApiFp(this.configuration).apiV1UserProfileNotificationGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Regenerate a new notification token for the current user.
     * @summary Regenerate the user\'s notification token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceApi
     */
    public apiV1UserProfileNotificationPut(options?: RawAxiosRequestConfig) {
        return UserResourceApiFp(this.configuration).apiV1UserProfileNotificationPut(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows an authenticated user to update their profile information.
     * @summary Update the profile data for the authenticated user
     * @param {ProfileDataUpdateRequest} [profileDataUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceApi
     */
    public apiV1UserProfilePut(profileDataUpdateRequest?: ProfileDataUpdateRequest, options?: RawAxiosRequestConfig) {
        return UserResourceApiFp(this.configuration).apiV1UserProfilePut(profileDataUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches the regional settings data for the authenticated user.
     * @summary Retrieve regional settings for the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceApi
     */
    public apiV1UserProfileRegionalGet(options?: RawAxiosRequestConfig) {
        return UserResourceApiFp(this.configuration).apiV1UserProfileRegionalGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the regional settings data for the authenticated user.
     * @summary Update regional settings for the user
     * @param {RegionalProfileDataRequest} [regionalProfileDataRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserResourceApi
     */
    public apiV1UserProfileRegionalPut(regionalProfileDataRequest?: RegionalProfileDataRequest, options?: RawAxiosRequestConfig) {
        return UserResourceApiFp(this.configuration).apiV1UserProfileRegionalPut(regionalProfileDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * WebHookResourceApi - axios parameter creator
 * @export
 */
export const WebHookResourceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {KeycloakEventRequest} [keycloakEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WebhookKeycloakEventWebhookPost: async (keycloakEventRequest?: KeycloakEventRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/webhook/keycloak_event_webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keycloakEventRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebHookResourceApi - functional programming interface
 * @export
 */
export const WebHookResourceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebHookResourceApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {KeycloakEventRequest} [keycloakEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1WebhookKeycloakEventWebhookPost(keycloakEventRequest?: KeycloakEventRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1WebhookKeycloakEventWebhookPost(keycloakEventRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['WebHookResourceApi.apiV1WebhookKeycloakEventWebhookPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * WebHookResourceApi - factory interface
 * @export
 */
export const WebHookResourceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebHookResourceApiFp(configuration)
    return {
        /**
         * 
         * @param {KeycloakEventRequest} [keycloakEventRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WebhookKeycloakEventWebhookPost(keycloakEventRequest?: KeycloakEventRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiV1WebhookKeycloakEventWebhookPost(keycloakEventRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebHookResourceApi - object-oriented interface
 * @export
 * @class WebHookResourceApi
 * @extends {BaseAPI}
 */
export class WebHookResourceApi extends BaseAPI {
    /**
     * 
     * @param {KeycloakEventRequest} [keycloakEventRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebHookResourceApi
     */
    public apiV1WebhookKeycloakEventWebhookPost(keycloakEventRequest?: KeycloakEventRequest, options?: RawAxiosRequestConfig) {
        return WebHookResourceApiFp(this.configuration).apiV1WebhookKeycloakEventWebhookPost(keycloakEventRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



